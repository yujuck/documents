책 내용 중에 잘 몰랐던 것만..

## 단항 연산자

### + 단항 연산자
+ 단항 연산자는 피연산자에 아무런 효과도 주지 않는다.

그대신 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫타 타입으로 변환하여 반환한다.<br />
이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성하여 반환하는 것이다.

```jsx
let x = "1";

console.log(+x);  // 1
console.log(x);  // "1"

x = true;
console.log(+x);  // 1
console.log(x);  // true

x = false;
console.log(+x);  // 0
console.log(x);  // false

x = "hello";
console.log(+x);  // NaN. 문자열을 숫자로 변환할 수 없기 때문에 NaN 리턴
console.log(x);  // "hello"
```
<br />

### - 단항 연산자
피연산자의 부호를 반전한 값을 반환한다.
+ 단항 연산자와 마찬가지로 변환한 값을 생성하여 반환한다.

```jsx
-(-10);  // 10
-'10';  // -10
-true;  // -1
-'hello';  // NaN
```

<br />

### 문자열 연결 연산자
+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```jsx
'1' + 2;  // '12'

1 + true;  // 2
1 + false;  // 1
1 + null;  // 1  null은 0으로 변환
+undefined;  // NaN  undefined는 숫자로 타입 변환 안됨
1 + undefined; // NaN


💡 위 예제에서 true, false가 숫자 타입으로 변환되고 연산이 수행되었는데,
이처럼 자바스크립트 엔진이 암묵적으로 타입을 변환시키는 것을
암묵적 타입 변환 또는 타입 강제 변환이라고 한다.
```
<br />

## 할당 연산자
```jsx
let x;
console.log(x=100);  // 100
```

할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.
위의 예제에서 x에 100을 할당하고 있는데, 이 할당문을 콘솔에 찍어보면 100이 출력된다.

이러한 특징을 사용해 같은 값을 여러 변수에 연쇄 할당할 수 있다.

```jsx
let a = b = c = 10;
```
<br />

## 비교 연산자

### 동등 비교 연산자 (==)

좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

https://262.ecma-international.org/5.1/#sec-11.9.3 이 알고리즘을 사용해 비교한다고 한다.

간략히 설명하자면
- 두 피연산자가 모두 객체일때, 두 피연산자가 동일한 객체를 참조할때에만 true를 반환합니다.
- 하나의 피연산자가 null이고 다른 하나가 undefined일때, true를 반환합니다.
- 두 피연산자의 타입이 다를 경우, 비교하기 전에 동일한 타입으로 변환하도록 합니다:
    - 숫자와 문자열을 비교할 경우, 문자열을 숫자로 변환하도록 합니다.
    - 하나의 피연산자가 Boolean일 경우, Boolean 피연산자가 true일 경우 1로 변환하고, false일 경우, +0으로 변환합니다.
    - 하나의 피연산자가 객체이고 다른하나가 숫자나 문자열이면, 객체를  valueOf()나toString()를 사용해 기본 데이터 타입으로 변환하도록 합니다.
- 두개의 피연산자가 동일한 타입일 경우, 다음과 같이 비교됩니다:
    - String: 두 피연산자가 동일한 문자순서가 동일한 문자열일 경우, true를 반환합니다.
    - Number: 두 피연산자가 동일한 값을 가질 경우, true을 반환합니다. +0 과 -0 은 동일한 값으로 취급합니다. 어느 한쪽이 NaN일 경우, false를 반환합니다.
    - Boolean: 두 피연산자가 모두 true이거나, 모두 false일 경우, true를 반환합니다. 

이런 알고리즘을 거쳐 비교를 한다고 한다..

```
💡 회사 면접 질문으로 팀장님이 동등 비교 연산자 사용 시,
암묵적으로 어떻게 타입을 변환시켜서 비교하는지에 대한 문제를 내셨고..
설명해주시기로는..!
자바스크립트에서 동등 연산자는 좌항을 기준으로 우항의 값을 형변환하려는 특징이 있다.
이때 좌항의 타입으로 변환이 가능한 것과 불가능한 경우로 나뉘는데,
변환이 불가능한 경우 자바스크립트의 최상위는 객체이기 때문에
해당 객체의 메소드인 toString()을 통해 문자열로 변환이 된다.
라고 설명해주셨다!!

팀장님은 저 위의 알고리즘을 읽어보셨던걸까..크..
```
<br />

### 일치 비교 연산자 (===)
좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
즉, 암묵적 타입 변환 없이 값을 비교한다.

NaN이 좀 특이한데, NaN은 자기 자신과도 동일하지 않다.
```jsx
console.log(Nan === NaN);  // false
console.log(isNaN(NaN));  // true;
```
NaN은 자신과 일치하지 않는 유일한 값이다.
NaN인지 판단할 때는 isNaN() 을 사용한다.

자바스크립트에는 양의 0, 음의 0이 있는데 이 둘은 비교하면 true가 나온다
```jsx
-0 === 0 ;  // true
0 == -0 ;  // true
```

```
💡 Object.is()
ES6에서 도입된 메서드인데, 예측 가능한 비교 결과를 반환한다.
그 외에는 일치 비교 연산자와 동일하게 작동한다.

Object.is(NaN, NaN);  // true
Object.is(-0, 0);  // false
Object.is(5, '5');  // false (일치 비교 연산자와 동일)

즉, 일반적으로 예측할 수 있는 결과를 반환해주는 메서드라고 생각하면 될 것 같다.
NaN과 NaN을 비교하면 눈으로 보기에 똑같기 때문에 true를 예측할 것이고
-0과 0을 비교하면 false라고 예측이 되는데 그 결과를 반환해주는 것이 Object.is()인 것!
```

<br />

## typeof 연산자

typeof 연산자는 7가지 문자열 중 하나를 반환한다.

> "string", "number", "boolean", "undefined", "symbol", "object", "function"

"null"을 반환하는 경우는 없다.  null은 "object"로 반환된다.
따라서 null을 확인할 때는 typeof가 아닌 일치 연산자(===)를 사용해야 한다.

```jsx
typeof null;  // "object"
```

또한 선언하지 않은 식별자를 typeof 연산자로 연산하면 ReferenceError가 아닌 `undefined`를 반환한다.







