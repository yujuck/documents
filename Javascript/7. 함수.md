## 함수

프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

<br />

### 함수의 구성 요소
- 매개변수 : 함수 내부로 입력을 전달받는 변수
- 인수 : 입력
- 반환값 : 출력
- 함수 이름 : 함수를 구별하기 위한 식별자

<br />

### 함수 리터럴

자바스크립트의 함수는 `객체 타입의 값`이다. 따라서 함수 리터럴로 생성할 수 있다.

함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.

```jsx
// 변수에 함수 리터럴을 할당
const f = function add(x, y) {
    return x + y;
}
```
함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 익명 함수라 한다. 

또한 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

자바스크립트에서 함수는 객체라는 사실은 자바스크립트의 중요한 특징이기 때문에 잘 알아둬야 한다..!

### 함수 정의

함수를 정의하는 방법에는 4가지가 있다.

1. 함수 선언문
```jsx
function add(x, y) {
    return x + y;
}
```
함수 선언문은 함수 이름을 생략할 수 없다.

또한 `표현식이 아닌 문`이다. 표현식이 아닌 문은 변수에 할당할 수 없다.

하지만 다음과 같은 예시를 보면 표현식인 문처럼 동작하는 것처럼 보인다.
```jsx
const add = function add(x, y) {
    return x + y;
}
```
이렇게 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을

`표현식이 아닌 문`인 `함수 선언문`으로 해석하는 경우와 `표현식인 문`인 `함수 리터럴 표현식`으로 해석하는 경우가 있기 때문이다.

단독으로 사용될 때는 함수 선언문으로 해석하지만 값으로 평가되어야 하는 문맥에서는 함수 리터럴 표현식으로 해석한다.

둘다 함수가 생성되지만 내부 동작에서 차이가 생긴다.

함수 선언문으로 생성된 함수는 호출할 수 있지만 함수 리터럴 표현식으로 생성된 함수는 호출할 수 없다.

```jsx
function test() { console.log('test'); }
test();

(function test2() { console.log('test2'); })
test2();  // ReferenceError: test2 is not defined
```

함수 리터럴 설명에서 함수 이름은 함수 몸체 내에서만 참조할 수 있다고 했다.<br />
test2는 함수 리터럴 표현식으로 해석되어 함수 이름으로는 함수를 참조할 수 없는데, 이것은 함수를 가리키는 식별자가 없다는 의미가 되고, 그렇기 때문에 호출할 수 없다.

근데 test도 함수 이름이 test인데 test로 호출할 수 있는 이유는<br />
자바스크립트 엔진이 생성된 함수를 호출하기 위해 암묵적으로 함수 이름과 동일한 이름의 식별자를 생성하고 거기에 함수 객체를 할당하기 때문이다.

<b>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출된다.</b>

<br />

2. 함수 표현식
```jsx
const add = function (x, y) {
    return x + y;
};
```
함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.

이러한 함수 정의 방식을 함수 표현식이라고 한다.

함수 리터럴의 함수 이름은 생략할 수 있고 이러한 함수를 익명함수라 하는데,<br />
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

<br />


### 💡 함수 생성 시점과 함수 호이스팅
함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 생성 시점이 다르다.

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있지만<br />
함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

함수 선언문도 다른 선언문과 마찬가지로 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. <br />
따라서 런타임 이전에 함수 객체가 먼저 생성된다.<br />
런타임에는 이미 함수 객체가 생성되어 있어서 선언문 이전에 함수를 참조할 수 있고 호출할 수도 있다.<br />
이를 <b>`함수 호이스팅`</b>이라고 한다.

함수 표현식은 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

변수 호이스팅은 런타임 때 undefined로 초기화 되고 런타임에 값이 할당된다.

따라서 함수 표현식은 함수를 할당한 변수에 대해 변수 호이스팅이 발생하여<br />
런타임 이전에는 undefined로 초기화 되고 런타임에, 즉 변수에 함수가 할당되는 시점에 함수 객체가 생성되어 그 이후부터 호출할 수 있다.

이러한 함수 호이스팅 때문에 함수 선언문 보다는 <b>함수 표현식으로 함수를 생성하는 것이 권장</b>된다.

<br />

3. Function 생성자 함수
```jsx
const add = new Function('x','y', 'return x+y');
```

** 생성자 함수 : 객체를 생성하는 함수

Function 생성자 함수로 함수를 생성하는 것은 일반적이지 않기도 하고,<br />
함수 선언문, 함수 표현식으로 생성한 함수와 다르게 동작하기도 한다. (클로저를 생성하지 않음)

<br />

4. 화살표 함수 (ES6)
```jsx
const add = (x, y) => x + y;
```
화살표 함수는 항상 익명 함수로 정의한다.

기존 함수와 다른점
- 생성자 함수로 사용할 수 없다.
- 기존 함수와 this 바인딩 방식이 다르다.
- prototype 프로퍼티가 없다
- arguments 객체를 생성하지 않는다.

